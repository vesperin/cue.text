package com.vesperin.text;

import com.vesperin.base.Source;

import java.util.Arrays;

/**
 * @author Huascar Sanchez
 */
public class Codebase {
  private Codebase(){}

  static Source quickSort(String name){
    return quickSort(name, "");
  }

  static Source quickSort(String name, String superClasses){
    return createCode(
      name,
      "package com.foo.best;",
      "import java.util.Random;",
      "",
      "public class " + name + " " + superClasses + " {",
      "  private static Random rand = new Random();",
      "",
      "  public static void quicksort(int[] arr, int left, int right) {",
      "    if (left < right) {",
      "      int pivots = randomizedPartition(arr, left, right);",
      "      quicksort(arr, left, pivots);",
      "      quicksort(arr, pivots + 1, right);",
      "    }",
      "  }",
      "",
      "  private static int randomizedPartition(int[] arr, int left, int right) {",
      "    int swapIndex = left + rand.nextInt(right - left) + 1;",
      "    swap(arr, left, swapIndex);",
      "    return partition(arr, left, right);",
      "  }",
      "",
      "  private static int partition(int[] arr, int left, int right) {",
      "    int pivot = arr[left];",
      "    int i = left - 1;",
      "    int j = right + 1;",
      "    while (true) {",
      "      do",
      "        j--;",
      "      while (arr[j] > pivot);",
      "",
      "      do",
      "        i++;",
      "      while (arr[i] < pivot);",
      "",
      "      if (i < j)",
      "        swap(arr, i, j);",
      "      else",
      "        return j;",
      "    }",
      "  }",
      "",
      "  private static void swap(int[] arr, int i, int j) {",
      "    int tmp = arr[i];",
      "    arr[i] = arr[j];",
      "    arr[j] = tmp;",
      "  }",
      "",
      "  // Sort 100k elements that are in reversed sorted order",
      "  public static void main(String[] args) {",
      "    int arr[] = new int[100000];",
      "    for (int i = 0; i < arr.length; i++)",
      "      arr[i] = arr.length - i;",
      "",
      "    System.out.println(\"First 20 elements\");",
      "    System.out.print(\"Before sort: \");",
      "    for (int i = 0; i < 20; i++)",
      "      System.out.print(arr[i] + \" \");",
      "    System.out.println();",
      "",
      "    quicksort(arr, 0, arr.length - 1);",
      "    System.out.print(\"After sort: \");",
      "    for (int i = 0; i < 20; i++)",
      "      System.out.print(arr[i] + \" \");",
      "    System.out.println();",
      "  }",
      "",
      "}"
    );
  }

  public static Source randomCode(String name){
    return createCode(name,
      "package com.foo.best;",
      "import java.util.ArrayList;",
      "import java.util.Arrays;",
      "import java.util.Collections;",
      "import java.util.Comparator;",
      "import java.util.HashMap;",
      "import java.util.Vector;",
      "import java.util.Map;",
      "import Jama.Matrix;",
      "",
      "public class " + name + " {	",
      "	",
      "	private Matrix tdMatrix;",
      "	private Vector<Document> documents;",
      "	private Vector<Term> terms;",
      "	private Vector<Term> vec4f = null;",
      "	",
      "	public Query(Vector<Term> terms, Vector<Document> documents, Matrix tdMatrix) {",
      "		this.terms= terms;",
      "		this.documents= documents;",
      "		this.tdMatrix= tdMatrix;",
      "	}",
      "	",
      "	/* Search function that returns a vector of query results */",
      "	public Vector<QueryResult> search(String query) {",
      "		String[] s= parser(query);",
      "		Vector<Term> q= new Vector<Term>();",
      "		for(int i= 0; i < s.length; i++) {",
      "			Term t= new Term(s[i]);",
      "			q.add(t);",
      "		}",
      "		Matrix queryMatrix= getQueryMatrix(q);",
      "		final Map<Document,Double> simMap= new HashMap<Document,Double>();",
      "		for(int i= 0; i < tdMatrix.getColumnDimension(); i++) {",
      "			double sim= computeSimilarity(queryMatrix, tdMatrix.getMatrix(0,", "tdMatrix.getRowDimension() -1, i, i));",
      "			if (sim > 0.0D) {",
      "				simMap.put(documents.get(i), sim);",
      "			}",
      "		}",
      "		return sortByScore(simMap);",
      "	}",
      "	",
      "	/* Transforms the query vector to the LSI space */",
      "	private Matrix getQueryMatrix(Vector<Term> query) {",
      "		Matrix queryMatrix= new Matrix(terms.size(), 1, 0.0D);",
      "		for(int i= 0; i < query.size(); i++) {",
      "			int termIndex= 0;",
      "			for(int j= 0; j < terms.size(); j++) {",
      "				if(query.get(i).compareTo(terms.get(j)) == 0) {",
      "					queryMatrix.set(termIndex, 0, 1.0D);",
      "				}",
      "				termIndex++;",
      "			}",
      "		}",
      "		queryMatrix= queryMatrix.times(1 / queryMatrix.norm1());",
      "		return queryMatrix;",
      "	}",
      "	",
      "	private Vector<QueryResult> sortByScore(final Map<Document,Double> simMap) {",
      "		Vector<QueryResult> results= new Vector<QueryResult>();",
      "		Vector<Document> docs= new Vector<Document>();",
      "		docs.addAll(simMap.keySet());",
      "		Collections.sort(docs, new Comparator<Document>() {",
      "			public int compare(Document d1, Document d2) {",
      "				return simMap.get(d2).compareTo(simMap.get(d1));",
      "			}",
      "		});",
      "		Vector<String> docNames= new Vector<String>();",
      "		double score;",
      "		for(int i= 0; i < docs.size(); i ++) {",
      "			String s= docs.get(i).toString();",
      "			docNames.add(s);",
      "		}",
      "		for(int j= 0; j < docNames.size(); j ++) {",
      "			score= simMap.get(docs.get(j));",
      "			if (score < 0.0001D) {",
      "				continue;",
      "			}",
      "",
      "			results.add(new QueryResult(docNames.get(j), score, docs.get(j)));",
      "		}",
      "		return results;",
      "	}",
      "	",
      "	/* Computes the cosine similarity measure to rank relevant documents */",
      "	public double computeSimilarity(Matrix sourceDoc, Matrix targetDoc) {",
      "		double dotProduct= sourceDoc.arrayTimes(targetDoc).norm1();",
      "		double eucledianDist= sourceDoc.normF() * targetDoc.normF();",
      "		return dotProduct / eucledianDist;",
      "	}",
      "	",
      "	public String[] parser(String line) {",
      "		String[] words = line.split(\" \");",
      "		for(int i= 0; i < words.length; i++) {",
      "			String t= words[i].toLowerCase();",
      "			words[i]= t;",
      "		}",
      "		return words;",
      "	}",
      "}"
    );
  }

  static Source failingCode(){
    return Source.from("PdfStamperImp", "package com.lowagie.text.pdf;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport org.xml.sax.SAXException;\nimport com.lowagie.text.Document;\nimport com.lowagie.text.DocumentException;\nimport com.lowagie.text.ExceptionConverter;\nimport com.lowagie.text.Image;\nimport com.lowagie.text.Rectangle;\nimport com.lowagie.text.exceptions.BadPasswordException;\nimport com.lowagie.text.pdf.collection.PdfCollection;\nimport com.lowagie.text.pdf.interfaces.PdfViewerPreferences;\nimport com.lowagie.text.pdf.internal.PdfViewerPreferencesImp;\nimport com.lowagie.text.xml.xmp.XmpReader;\n\nclass PdfStamperImp extends PdfWriter {\n\n    HashMap readers2intrefs = new HashMap();\n\n    HashMap readers2file = new HashMap();\n\n    RandomAccessFileOrArray file;\n\n    PdfReader reader;\n\n    IntHashtable myXref = new IntHashtable();\n\n    /** Integer(page number) -> PageStamp */\n    HashMap pagesToContent = new HashMap();\n\n    boolean closed = false;\n\n    /** Holds value of property rotateContents. */\n    private boolean rotateContents = true;\n\n    protected AcroFields acroFields;\n\n    protected boolean flat = false;\n\n    protected boolean flatFreeText = false;\n\n    protected int namePtr[] = { 0 };\n\n    protected HashSet partialFlattening = new HashSet();\n\n    protected boolean useVp = false;\n\n    protected PdfViewerPreferencesImp viewerPreferences = new PdfViewerPreferencesImp();\n\n    protected HashMap fieldTemplates = new HashMap();\n\n    protected boolean fieldsAdded = false;\n\n    protected int sigFlags = 0;\n\n    protected boolean append;\n\n    protected IntHashtable marked;\n\n    protected int initialXrefSize;\n\n    protected PdfAction openAction;\n\n    /** Creates new PdfStamperImp.\n     * @param reader the read PDF\n     * @param os the output destination\n     * @param pdfVersion the new pdf version or '\\0' to keep the same version as the original\n     * document\n     * @param append\n     * @throws DocumentException on error\n     * @throws IOException\n     */\n    PdfStamperImp(PdfReader reader, OutputStream os, char pdfVersion, boolean append) throws DocumentException, IOException {\n        super(new PdfDocument(), os);\n        if (!reader.isOpenedWithFullPermissions()) throw new BadPasswordException(\"PdfReader not opened with owner password\");\n        if (reader.isTampered()) throw new DocumentException(\"The original document was reused. Read it again from file.\");\n        reader.setTampered(true);\n        this.reader = reader;\n        file = reader.getSafeFile();\n        this.append = append;\n        if (append) {\n            if (reader.isRebuilt()) throw new DocumentException(\"Append mode requires a document without errors even if recovery was possible.\");\n            if (reader.isEncrypted()) crypto = new PdfEncryption(reader.getDecrypt());\n            pdf_version.setAppendmode(true);\n            file.reOpen();\n            byte buf[] = new byte[8192];\n            int n;\n            while ((n = file.read(buf)) > 0) this.os.write(buf, 0, n);\n            file.close();\n            prevxref = reader.getLastXref();\n            reader.setAppendable(true);\n        } else {\n            if (pdfVersion == 0) super.setPdfVersion(reader.getPdfVersion()); else super.setPdfVersion(pdfVersion);\n        }\n        super.open();\n        pdf.addWriter(this);\n        if (append) {\n            body.setRefnum(reader.getXrefSize());\n            marked = new IntHashtable();\n            if (reader.isNewXrefType()) fullCompression = true;\n            if (reader.isHybridXref()) fullCompression = false;\n        }\n        initialXrefSize = reader.getXrefSize();\n    }\n\n    void close(HashMap moreInfo) throws IOException {\n        if (closed) return;\n        if (useVp) {\n            reader.setViewerPreferences(viewerPreferences);\n            markUsed(reader.getTrailer().get(PdfName.ROOT));\n        }\n        if (flat) flatFields();\n        if (flatFreeText) flatFreeTextFields();\n        addFieldResources();\n        PdfDictionary catalog = reader.getCatalog();\n        PdfDictionary pages = (PdfDictionary) PdfReader.getPdfObject(catalog.get(PdfName.PAGES));\n        pages.put(PdfName.ITXT, new PdfString(Document.getRelease()));\n        markUsed(pages);\n        PdfDictionary acroForm = (PdfDictionary) PdfReader.getPdfObject(catalog.get(PdfName.ACROFORM), reader.getCatalog());\n        if (acroFields != null && acroFields.getXfa().isChanged()) {\n            markUsed(acroForm);\n            if (!flat) acroFields.getXfa().setXfa(this);\n        }\n        if (sigFlags != 0) {\n            if (acroForm != null) {\n                acroForm.put(PdfName.SIGFLAGS, new PdfNumber(sigFlags));\n                markUsed(acroForm);\n                markUsed(catalog);\n            }\n        }\n        closed = true;\n        addSharedObjectsToBody();\n        setOutlines();\n        setJavaScript();\n        addFileAttachments();\n        if (openAction != null) {\n            catalog.put(PdfName.OPENACTION, openAction);\n        }\n        if (pdf.pageLabels != null) catalog.put(PdfName.PAGELABELS, pdf.pageLabels.getDictionary(this));\n        if (!documentOCG.isEmpty()) {\n            fillOCProperties(false);\n            PdfDictionary ocdict = catalog.getAsDict(PdfName.OCPROPERTIES);\n            if (ocdict == null) {\n                reader.getCatalog().put(PdfName.OCPROPERTIES, OCProperties);\n            } else {\n                ocdict.put(PdfName.OCGS, OCProperties.get(PdfName.OCGS));\n                PdfDictionary ddict = ocdict.getAsDict(PdfName.D);\n                if (ddict == null) {\n                    ddict = new PdfDictionary();\n                    ocdict.put(PdfName.D, ddict);\n                }\n                ddict.put(PdfName.ORDER, OCProperties.getAsDict(PdfName.D).get(PdfName.ORDER));\n                ddict.put(PdfName.RBGROUPS, OCProperties.getAsDict(PdfName.D).get(PdfName.RBGROUPS));\n                ddict.put(PdfName.OFF, OCProperties.getAsDict(PdfName.D).get(PdfName.OFF));\n                ddict.put(PdfName.AS, OCProperties.getAsDict(PdfName.D).get(PdfName.AS));\n            }\n        }\n        int skipInfo = -1;\n        PRIndirectReference iInfo = (PRIndirectReference) reader.getTrailer().get(PdfName.INFO);\n        PdfDictionary oldInfo = (PdfDictionary) PdfReader.getPdfObject(iInfo);\n        String producer = null;\n        if (iInfo != null) skipInfo = iInfo.getNumber();\n        if (oldInfo != null && oldInfo.get(PdfName.PRODUCER) != null) producer = oldInfo.getAsString(PdfName.PRODUCER).toString();\n        if (producer == null) {\n            producer = Document.getVersion();\n        } else if (producer.indexOf(Document.getProduct()) == -1) {\n            StringBuffer buf = new StringBuffer(producer);\n            buf.append(\"; modified using \");\n            buf.append(Document.getVersion());\n            producer = buf.toString();\n        }\n        byte[] altMetadata = null;\n        PdfObject xmpo = PdfReader.getPdfObject(catalog.get(PdfName.METADATA));\n        if (xmpo != null && xmpo.isStream()) {\n            altMetadata = PdfReader.getStreamBytesRaw((PRStream) xmpo);\n            PdfReader.killIndirect(catalog.get(PdfName.METADATA));\n        }\n        if (xmpMetadata != null) {\n            altMetadata = xmpMetadata;\n        }\n        PdfDate date = new PdfDate();\n        if (altMetadata != null) {\n            PdfStream xmp;\n            try {\n                XmpReader xmpr = new XmpReader(altMetadata);\n                if (!xmpr.replace(\"http://ns.adobe.com/pdf/1.3/\", \"Producer\", producer)) xmpr.add(\"rdf:Description\", \"http://ns.adobe.com/pdf/1.3/\", \"pdf:Producer\", producer);\n                if (!xmpr.replace(\"http://ns.adobe.com/xap/1.0/\", \"ModifyDate\", date.getW3CDate())) xmpr.add(\"rdf:Description\", \"http://ns.adobe.com/xap/1.0/\", \"xmp:ModifyDate\", date.getW3CDate());\n                xmpr.replace(\"http://ns.adobe.com/xap/1.0/\", \"MetadataDate\", date.getW3CDate());\n                xmp = new PdfStream(xmpr.serializeDoc());\n            } catch (SAXException e) {\n                xmp = new PdfStream(altMetadata);\n            } catch (IOException e) {\n                xmp = new PdfStream(altMetadata);\n            }\n            xmp.put(PdfName.TYPE, PdfName.METADATA);\n            xmp.put(PdfName.SUBTYPE, PdfName.XML);\n            if (crypto != null && !crypto.isMetadataEncrypted()) {\n                PdfArray ar = new PdfArray();\n                ar.add(PdfName.CRYPT);\n                xmp.put(PdfName.FILTER, ar);\n            }\n            if (append && xmpo != null) {\n                body.add(xmp, xmpo.getIndRef());\n            } else {\n                catalog.put(PdfName.METADATA, body.add(xmp).getIndirectReference());\n                markUsed(catalog);\n            }\n        }\n        try {\n            file.reOpen();\n            alterContents();\n            int rootN = ((PRIndirectReference) reader.trailer.get(PdfName.ROOT)).getNumber();\n            if (append) {\n                int keys[] = marked.getKeys();\n                for (int k = 0; k < keys.length; ++k) {\n                    int j = keys[k];\n                    PdfObject obj = reader.getPdfObjectRelease(j);\n                    if (obj != null && skipInfo != j && j < initialXrefSize) {\n                        addToBody(obj, j, j != rootN);\n                    }\n                }\n                for (int k = initialXrefSize; k < reader.getXrefSize(); ++k) {\n                    PdfObject obj = reader.getPdfObject(k);\n                    if (obj != null) {\n                        addToBody(obj, getNewObjectNumber(reader, k, 0));\n                    }\n                }\n            } else {\n                for (int k = 1; k < reader.getXrefSize(); ++k) {\n                    PdfObject obj = reader.getPdfObjectRelease(k);\n                    if (obj != null && skipInfo != k) {\n                        addToBody(obj, getNewObjectNumber(reader, k, 0), k != rootN);\n                    }\n                }\n            }\n        } finally {\n            try {\n                file.close();\n            } catch (Exception e) {\n            }\n        }\n        PdfIndirectReference encryption = null;\n        PdfObject fileID = null;\n        if (crypto != null) {\n            if (append) {\n                encryption = reader.getCryptoRef();\n            } else {\n                PdfIndirectObject encryptionObject = addToBody(crypto.getEncryptionDictionary(), false);\n                encryption = encryptionObject.getIndirectReference();\n            }\n            fileID = crypto.getFileID();\n        } else fileID = PdfEncryption.createInfoId(PdfEncryption.createDocumentId());\n        PRIndirectReference iRoot = (PRIndirectReference) reader.trailer.get(PdfName.ROOT);\n        PdfIndirectReference root = new PdfIndirectReference(0, getNewObjectNumber(reader, iRoot.getNumber(), 0));\n        PdfIndirectReference info = null;\n        PdfDictionary newInfo = new PdfDictionary();\n        if (oldInfo != null) {\n            for (Iterator i = oldInfo.getKeys().iterator(); i.hasNext(); ) {\n                PdfName key = (PdfName) i.next();\n                PdfObject value = PdfReader.getPdfObject(oldInfo.get(key));\n                newInfo.put(key, value);\n            }\n        }\n        if (moreInfo != null) {\n            for (Iterator i = moreInfo.entrySet().iterator(); i.hasNext(); ) {\n                Map.Entry entry = (Map.Entry) i.next();\n                String key = (String) entry.getKey();\n                PdfName keyName = new PdfName(key);\n                String value = (String) entry.getValue();\n                if (value == null) newInfo.remove(keyName); else newInfo.put(keyName, new PdfString(value, PdfObject.TEXT_UNICODE));\n            }\n        }\n        newInfo.put(PdfName.MODDATE, date);\n        newInfo.put(PdfName.PRODUCER, new PdfString(producer));\n        if (append) {\n            if (iInfo == null) info = addToBody(newInfo, false).getIndirectReference(); else info = addToBody(newInfo, iInfo.getNumber(), false).getIndirectReference();\n        } else {\n            info = addToBody(newInfo, false).getIndirectReference();\n        }\n        body.writeCrossReferenceTable(os, root, info, encryption, fileID, prevxref);\n        if (fullCompression) {\n            os.write(getISOBytes(\"startxref\\n\"));\n            os.write(getISOBytes(String.valueOf(body.offset())));\n            os.write(getISOBytes(\"\\n%%EOF\\n\"));\n        } else {\n            PdfTrailer trailer = new PdfTrailer(body.size(), body.offset(), root, info, encryption, fileID, prevxref);\n            trailer.toPdf(this, os);\n        }\n        os.flush();\n        if (isCloseStream()) os.close();\n        reader.close();\n    }\n\n    void applyRotation(PdfDictionary pageN, ByteBuffer out) {\n        if (!rotateContents) return;\n        Rectangle page = reader.getPageSizeWithRotation(pageN);\n        int rotation = page.getRotation();\n        switch(rotation) {\n            case 90:\n                out.append(PdfContents.ROTATE90);\n                out.append(page.getTop());\n                out.append(' ').append('0').append(PdfContents.ROTATEFINAL);\n                break;\n            case 180:\n                out.append(PdfContents.ROTATE180);\n                out.append(page.getRight());\n                out.append(' ');\n                out.append(page.getTop());\n                out.append(PdfContents.ROTATEFINAL);\n                break;\n            case 270:\n                out.append(PdfContents.ROTATE270);\n                out.append('0').append(' ');\n                out.append(page.getRight());\n                out.append(PdfContents.ROTATEFINAL);\n                break;\n        }\n    }\n\n    void alterContents() throws IOException {\n        for (Iterator i = pagesToContent.values().iterator(); i.hasNext(); ) {\n            PageStamp ps = (PageStamp) i.next();\n            PdfDictionary pageN = ps.pageN;\n            markUsed(pageN);\n            PdfArray ar = null;\n            PdfObject content = PdfReader.getPdfObject(pageN.get(PdfName.CONTENTS), pageN);\n            if (content == null) {\n                ar = new PdfArray();\n                pageN.put(PdfName.CONTENTS, ar);\n            } else if (content.isArray()) {\n                ar = (PdfArray) content;\n                markUsed(ar);\n            } else if (content.isStream()) {\n                ar = new PdfArray();\n                ar.add(pageN.get(PdfName.CONTENTS));\n                pageN.put(PdfName.CONTENTS, ar);\n            } else {\n                ar = new PdfArray();\n                pageN.put(PdfName.CONTENTS, ar);\n            }\n            ByteBuffer out = new ByteBuffer();\n            if (ps.under != null) {\n                out.append(PdfContents.SAVESTATE);\n                applyRotation(pageN, out);\n                out.append(ps.under.getInternalBuffer());\n                out.append(PdfContents.RESTORESTATE);\n            }\n            if (ps.over != null) out.append(PdfContents.SAVESTATE);\n            PdfStream stream = new PdfStream(out.toByteArray());\n            stream.flateCompress(compressionLevel);\n            ar.addFirst(addToBody(stream).getIndirectReference());\n            out.reset();\n            if (ps.over != null) {\n                out.append(' ');\n                out.append(PdfContents.RESTORESTATE);\n                ByteBuffer buf = ps.over.getInternalBuffer();\n                out.append(buf.getBuffer(), 0, ps.replacePoint);\n                out.append(PdfContents.SAVESTATE);\n                applyRotation(pageN, out);\n                out.append(buf.getBuffer(), ps.replacePoint, buf.size() - ps.replacePoint);\n                out.append(PdfContents.RESTORESTATE);\n                stream = new PdfStream(out.toByteArray());\n                stream.flateCompress(compressionLevel);\n                ar.add(addToBody(stream).getIndirectReference());\n            }\n            alterResources(ps);\n        }\n    }\n\n    void alterResources(PageStamp ps) {\n        ps.pageN.put(PdfName.RESOURCES, ps.pageResources.getResources());\n    }\n\n    protected int getNewObjectNumber(PdfReader reader, int number, int generation) {\n        IntHashtable ref = (IntHashtable) readers2intrefs.get(reader);\n        if (ref != null) {\n            int n = ref.get(number);\n            if (n == 0) {\n                n = getIndirectReferenceNumber();\n                ref.put(number, n);\n            }\n            return n;\n        }\n        if (currentPdfReaderInstance == null) {\n            if (append && number < initialXrefSize) return number;\n            int n = myXref.get(number);\n            if (n == 0) {\n                n = getIndirectReferenceNumber();\n                myXref.put(number, n);\n            }\n            return n;\n        } else return currentPdfReaderInstance.getNewObjectNumber(number, generation);\n    }\n\n    RandomAccessFileOrArray getReaderFile(PdfReader reader) {\n        if (readers2intrefs.containsKey(reader)) {\n            RandomAccessFileOrArray raf = (RandomAccessFileOrArray) readers2file.get(reader);\n            if (raf != null) return raf;\n            return reader.getSafeFile();\n        }\n        if (currentPdfReaderInstance == null) return file; else return currentPdfReaderInstance.getReaderFile();\n    }\n\n    /**\n     * @param reader\n     * @param openFile\n     * @throws IOException\n     */\n    public void registerReader(PdfReader reader, boolean openFile) throws IOException {\n        if (readers2intrefs.containsKey(reader)) return;\n        readers2intrefs.put(reader, new IntHashtable());\n        if (openFile) {\n            RandomAccessFileOrArray raf = reader.getSafeFile();\n            readers2file.put(reader, raf);\n            raf.reOpen();\n        }\n    }\n\n    /**\n     * @param reader\n     */\n    public void unRegisterReader(PdfReader reader) {\n        if (!readers2intrefs.containsKey(reader)) return;\n        readers2intrefs.remove(reader);\n        RandomAccessFileOrArray raf = (RandomAccessFileOrArray) readers2file.get(reader);\n        if (raf == null) return;\n        readers2file.remove(reader);\n        try {\n            raf.close();\n        } catch (Exception e) {\n        }\n    }\n\n    static void findAllObjects(PdfReader reader, PdfObject obj, IntHashtable hits) {\n        if (obj == null) return;\n        switch(obj.type()) {\n            case PdfObject.INDIRECT:\n                PRIndirectReference iref = (PRIndirectReference) obj;\n                if (reader != iref.getReader()) return;\n                if (hits.containsKey(iref.getNumber())) return;\n                hits.put(iref.getNumber(), 1);\n                findAllObjects(reader, PdfReader.getPdfObject(obj), hits);\n                return;\n            case PdfObject.ARRAY:\n                PdfArray a = (PdfArray) obj;\n                for (int k = 0; k < a.size(); ++k) {\n                    findAllObjects(reader, a.getPdfObject(k), hits);\n                }\n                return;\n            case PdfObject.DICTIONARY:\n            case PdfObject.STREAM:\n                PdfDictionary dic = (PdfDictionary) obj;\n                for (Iterator it = dic.getKeys().iterator(); it.hasNext(); ) {\n                    PdfName name = (PdfName) it.next();\n                    findAllObjects(reader, dic.get(name), hits);\n                }\n                return;\n        }\n    }\n\n    /**\n     * @param fdf\n     * @throws IOException\n     */\n    public void addComments(FdfReader fdf) throws IOException {\n        if (readers2intrefs.containsKey(fdf)) return;\n        PdfDictionary catalog = fdf.getCatalog();\n        catalog = catalog.getAsDict(PdfName.FDF);\n        if (catalog == null) return;\n        PdfArray annots = catalog.getAsArray(PdfName.ANNOTS);\n        if (annots == null || annots.size() == 0) return;\n        registerReader(fdf, false);\n        IntHashtable hits = new IntHashtable();\n        HashMap irt = new HashMap();\n        ArrayList an = new ArrayList();\n        for (int k = 0; k < annots.size(); ++k) {\n            PdfObject obj = annots.getPdfObject(k);\n            PdfDictionary annot = (PdfDictionary) PdfReader.getPdfObject(obj);\n            PdfNumber page = annot.getAsNumber(PdfName.PAGE);\n            if (page == null || page.intValue() >= reader.getNumberOfPages()) continue;\n            findAllObjects(fdf, obj, hits);\n            an.add(obj);\n            if (obj.type() == PdfObject.INDIRECT) {\n                PdfObject nm = PdfReader.getPdfObject(annot.get(PdfName.NM));\n                if (nm != null && nm.type() == PdfObject.STRING) irt.put(nm.toString(), obj);\n            }\n        }\n        int arhits[] = hits.getKeys();\n        for (int k = 0; k < arhits.length; ++k) {\n            int n = arhits[k];\n            PdfObject obj = fdf.getPdfObject(n);\n            if (obj.type() == PdfObject.DICTIONARY) {\n                PdfObject str = PdfReader.getPdfObject(((PdfDictionary) obj).get(PdfName.IRT));\n                if (str != null && str.type() == PdfObject.STRING) {\n                    PdfObject i = (PdfObject) irt.get(str.toString());\n                    if (i != null) {\n                        PdfDictionary dic2 = new PdfDictionary();\n                        dic2.merge((PdfDictionary) obj);\n                        dic2.put(PdfName.IRT, i);\n                        obj = dic2;\n                    }\n                }\n            }\n            addToBody(obj, getNewObjectNumber(fdf, n, 0));\n        }\n        for (int k = 0; k < an.size(); ++k) {\n            PdfObject obj = (PdfObject) an.get(k);\n            PdfDictionary annot = (PdfDictionary) PdfReader.getPdfObject(obj);\n            PdfNumber page = annot.getAsNumber(PdfName.PAGE);\n            PdfDictionary dic = reader.getPageN(page.intValue() + 1);\n            PdfArray annotsp = (PdfArray) PdfReader.getPdfObject(dic.get(PdfName.ANNOTS), dic);\n            if (annotsp == null) {\n                annotsp = new PdfArray();\n                dic.put(PdfName.ANNOTS, annotsp);\n                markUsed(dic);\n            }\n            markUsed(annotsp);\n            annotsp.add(obj);\n        }\n    }\n\n    PageStamp getPageStamp(int pageNum) {\n        PdfDictionary pageN = reader.getPageN(pageNum);\n        PageStamp ps = (PageStamp) pagesToContent.get(pageN);\n        if (ps == null) {\n            ps = new PageStamp(this, reader, pageN);\n            pagesToContent.put(pageN, ps);\n        }\n        return ps;\n    }\n\n    PdfContentByte getUnderContent(int pageNum) {\n        if (pageNum < 1 || pageNum > reader.getNumberOfPages()) return null;\n        PageStamp ps = getPageStamp(pageNum);\n        if (ps.under == null) ps.under = new StampContent(this, ps);\n        return ps.under;\n    }\n\n    PdfContentByte getOverContent(int pageNum) {\n        if (pageNum < 1 || pageNum > reader.getNumberOfPages()) return null;\n        PageStamp ps = getPageStamp(pageNum);\n        if (ps.over == null) ps.over = new StampContent(this, ps);\n        return ps.over;\n    }\n\n    void correctAcroFieldPages(int page) {\n        if (acroFields == null) return;\n        if (page > reader.getNumberOfPages()) return;\n        HashMap fields = acroFields.getFields();\n        for (Iterator it = fields.values().iterator(); it.hasNext(); ) {\n            AcroFields.Item item = (AcroFields.Item) it.next();\n            for (int k = 0; k < item.size(); ++k) {\n                int p = item.getPage(k).intValue();\n                if (p >= page) item.forcePage(k, p + 1);\n            }\n        }\n    }\n\n    private static void moveRectangle(PdfDictionary dic2, PdfReader r, int pageImported, PdfName key, String name) {\n        Rectangle m = r.getBoxSize(pageImported, name);\n        if (m == null) dic2.remove(key); else dic2.put(key, new PdfRectangle(m));\n    }\n\n    void replacePage(PdfReader r, int pageImported, int pageReplaced) {\n        PdfDictionary pageN = reader.getPageN(pageReplaced);\n        if (pagesToContent.containsKey(pageN)) throw new IllegalStateException(\"This page cannot be replaced: new content was already added\");\n        PdfImportedPage p = getImportedPage(r, pageImported);\n        PdfDictionary dic2 = reader.getPageNRelease(pageReplaced);\n        dic2.remove(PdfName.RESOURCES);\n        dic2.remove(PdfName.CONTENTS);\n        moveRectangle(dic2, r, pageImported, PdfName.MEDIABOX, \"media\");\n        moveRectangle(dic2, r, pageImported, PdfName.CROPBOX, \"crop\");\n        moveRectangle(dic2, r, pageImported, PdfName.TRIMBOX, \"trim\");\n        moveRectangle(dic2, r, pageImported, PdfName.ARTBOX, \"art\");\n        moveRectangle(dic2, r, pageImported, PdfName.BLEEDBOX, \"bleed\");\n        dic2.put(PdfName.ROTATE, new PdfNumber(r.getPageRotation(pageImported)));\n        PdfContentByte cb = getOverContent(pageReplaced);\n        cb.addTemplate(p, 0, 0);\n        PageStamp ps = (PageStamp) pagesToContent.get(pageN);\n        ps.replacePoint = ps.over.getInternalBuffer().size();\n    }\n\n    void insertPage(int pageNumber, Rectangle mediabox) {\n        Rectangle media = new Rectangle(mediabox);\n        int rotation = media.getRotation() % 360;\n        PdfDictionary page = new PdfDictionary(PdfName.PAGE);\n        PdfDictionary resources = new PdfDictionary();\n        PdfArray procset = new PdfArray();\n        procset.add(PdfName.PDF);\n        procset.add(PdfName.TEXT);\n        procset.add(PdfName.IMAGEB);\n        procset.add(PdfName.IMAGEC);\n        procset.add(PdfName.IMAGEI);\n        resources.put(PdfName.PROCSET, procset);\n        page.put(PdfName.RESOURCES, resources);\n        page.put(PdfName.ROTATE, new PdfNumber(rotation));\n        page.put(PdfName.MEDIABOX, new PdfRectangle(media, rotation));\n        PRIndirectReference pref = reader.addPdfObject(page);\n        PdfDictionary parent;\n        PRIndirectReference parentRef;\n        if (pageNumber > reader.getNumberOfPages()) {\n            PdfDictionary lastPage = reader.getPageNRelease(reader.getNumberOfPages());\n            parentRef = (PRIndirectReference) lastPage.get(PdfName.PARENT);\n            parentRef = new PRIndirectReference(reader, parentRef.getNumber());\n            parent = (PdfDictionary) PdfReader.getPdfObject(parentRef);\n            PdfArray kids = (PdfArray) PdfReader.getPdfObject(parent.get(PdfName.KIDS), parent);\n            kids.add(pref);\n            markUsed(kids);\n            reader.pageRefs.insertPage(pageNumber, pref);\n        } else {\n            if (pageNumber < 1) pageNumber = 1;\n            PdfDictionary firstPage = reader.getPageN(pageNumber);\n            PRIndirectReference firstPageRef = reader.getPageOrigRef(pageNumber);\n            reader.releasePage(pageNumber);\n            parentRef = (PRIndirectReference) firstPage.get(PdfName.PARENT);\n            parentRef = new PRIndirectReference(reader, parentRef.getNumber());\n            parent = (PdfDictionary) PdfReader.getPdfObject(parentRef);\n            PdfArray kids = (PdfArray) PdfReader.getPdfObject(parent.get(PdfName.KIDS), parent);\n            int len = kids.size();\n            int num = firstPageRef.getNumber();\n            for (int k = 0; k < len; ++k) {\n                PRIndirectReference cur = (PRIndirectReference) kids.getPdfObject(k);\n                if (num == cur.getNumber()) {\n                    kids.add(k, pref);\n                    break;\n                }\n            }\n            if (len == kids.size()) throw new RuntimeException(\"Internal inconsistence.\");\n            markUsed(kids);\n            reader.pageRefs.insertPage(pageNumber, pref);\n            correctAcroFieldPages(pageNumber);\n        }\n        page.put(PdfName.PARENT, parentRef);\n        while (parent != null) {\n            markUsed(parent);\n            PdfNumber count = (PdfNumber) PdfReader.getPdfObjectRelease(parent.get(PdfName.COUNT));\n            parent.put(PdfName.COUNT, new PdfNumber(count.intValue() + 1));\n            parent = parent.getAsDict(PdfName.PARENT);\n        }\n    }\n\n    /** Getter for property rotateContents.\n     * @return Value of property rotateContents.\n     *\n     */\n    boolean isRotateContents() {\n        return this.rotateContents;\n    }\n\n    /** Setter for property rotateContents.\n     * @param rotateContents New value of property rotateContents.\n     *\n     */\n    void setRotateContents(boolean rotateContents) {\n        this.rotateContents = rotateContents;\n    }\n\n    boolean isContentWritten() {\n        return body.size() > 1;\n    }\n\n    AcroFields getAcroFields() {\n        if (acroFields == null) {\n            acroFields = new AcroFields(reader, this);\n        }\n        return acroFields;\n    }\n\n    void setFormFlattening(boolean flat) {\n        this.flat = flat;\n    }\n\n    void setFreeTextFlattening(boolean flat) {\n        this.flatFreeText = flat;\n    }\n\n    boolean partialFormFlattening(String name) {\n        getAcroFields();\n        if (acroFields.getXfa().isXfaPresent()) throw new UnsupportedOperationException(\"Partial form flattening is not supported with XFA forms.\");\n        if (!acroFields.getFields().containsKey(name)) return false;\n        partialFlattening.add(name);\n        return true;\n    }\n\n    void flatFields() {\n        if (append) throw new IllegalArgumentException(\"Field flattening is not supported in append mode.\");\n        getAcroFields();\n        HashMap fields = acroFields.getFields();\n        if (fieldsAdded && partialFlattening.isEmpty()) {\n            for (Iterator i = fields.keySet().iterator(); i.hasNext(); ) {\n                partialFlattening.add(i.next());\n            }\n        }\n        PdfDictionary acroForm = reader.getCatalog().getAsDict(PdfName.ACROFORM);\n        PdfArray acroFds = null;\n        if (acroForm != null) {\n            acroFds = (PdfArray) PdfReader.getPdfObject(acroForm.get(PdfName.FIELDS), acroForm);\n        }\n        for (Iterator i = fields.entrySet().iterator(); i.hasNext(); ) {\n            Map.Entry entry = (Map.Entry) i.next();\n            String name = (String) entry.getKey();\n            if (!partialFlattening.isEmpty() && !partialFlattening.contains(name)) continue;\n            AcroFields.Item item = (AcroFields.Item) entry.getValue();\n            for (int k = 0; k < item.size(); ++k) {\n                PdfDictionary merged = item.getMerged(k);\n                PdfNumber ff = merged.getAsNumber(PdfName.F);\n                int flags = 0;\n                if (ff != null) flags = ff.intValue();\n                int page = item.getPage(k).intValue();\n                PdfDictionary appDic = merged.getAsDict(PdfName.AP);\n                if (appDic != null && (flags & PdfFormField.FLAGS_PRINT) != 0 && (flags & PdfFormField.FLAGS_HIDDEN) == 0) {\n                    PdfObject obj = appDic.get(PdfName.N);\n                    PdfAppearance app = null;\n                    if (obj != null) {\n                        PdfObject objReal = PdfReader.getPdfObject(obj);\n                        if (obj instanceof PdfIndirectReference && !obj.isIndirect()) app = new PdfAppearance((PdfIndirectReference) obj); else if (objReal instanceof PdfStream) {\n                            ((PdfDictionary) objReal).put(PdfName.SUBTYPE, PdfName.FORM);\n                            app = new PdfAppearance((PdfIndirectReference) obj);\n                        } else {\n                            if (objReal != null && objReal.isDictionary()) {\n                                PdfName as = merged.getAsName(PdfName.AS);\n                                if (as != null) {\n                                    PdfIndirectReference iref = (PdfIndirectReference) ((PdfDictionary) objReal).get(as);\n                                    if (iref != null) {\n                                        app = new PdfAppearance(iref);\n                                        if (iref.isIndirect()) {\n                                            objReal = PdfReader.getPdfObject(iref);\n                                            ((PdfDictionary) objReal).put(PdfName.SUBTYPE, PdfName.FORM);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (app != null) {\n                        Rectangle box = PdfReader.getNormalizedRectangle(merged.getAsArray(PdfName.RECT));\n                        PdfContentByte cb = getOverContent(page);\n                        cb.setLiteral(\"Q \");\n                        cb.addTemplate(app, box.getLeft(), box.getBottom());\n                        cb.setLiteral(\"q \");\n                    }\n                }\n                if (partialFlattening.isEmpty()) continue;\n                PdfDictionary pageDic = reader.getPageN(page);\n                PdfArray annots = pageDic.getAsArray(PdfName.ANNOTS);\n                if (annots == null) continue;\n                for (int idx = 0; idx < annots.size(); ++idx) {\n                    PdfObject ran = annots.getPdfObject(idx);\n                    if (!ran.isIndirect()) continue;\n                    PdfObject ran2 = item.getWidgetRef(k);\n                    if (!ran2.isIndirect()) continue;\n                    if (((PRIndirectReference) ran).getNumber() == ((PRIndirectReference) ran2).getNumber()) {\n                        annots.remove(idx--);\n                        PRIndirectReference wdref = (PRIndirectReference) ran2;\n                        while (true) {\n                            PdfDictionary wd = (PdfDictionary) PdfReader.getPdfObject(wdref);\n                            PRIndirectReference parentRef = (PRIndirectReference) wd.get(PdfName.PARENT);\n                            PdfReader.killIndirect(wdref);\n                            if (parentRef == null) {\n                                for (int fr = 0; fr < acroFds.size(); ++fr) {\n                                    PdfObject h = acroFds.getPdfObject(fr);\n                                    if (h.isIndirect() && ((PRIndirectReference) h).getNumber() == wdref.getNumber()) {\n                                        acroFds.remove(fr);\n                                        --fr;\n                                    }\n                                }\n                                break;\n                            }\n                            PdfDictionary parent = (PdfDictionary) PdfReader.getPdfObject(parentRef);\n                            PdfArray kids = parent.getAsArray(PdfName.KIDS);\n                            for (int fr = 0; fr < kids.size(); ++fr) {\n                                PdfObject h = kids.getPdfObject(fr);\n                                if (h.isIndirect() && ((PRIndirectReference) h).getNumber() == wdref.getNumber()) {\n                                    kids.remove(fr);\n                                    --fr;\n                                }\n                            }\n                            if (!kids.isEmpty()) break;\n                            wdref = parentRef;\n                        }\n                    }\n                }\n                if (annots.isEmpty()) {\n                    PdfReader.killIndirect(pageDic.get(PdfName.ANNOTS));\n                    pageDic.remove(PdfName.ANNOTS);\n                }\n            }\n        }\n        if (!fieldsAdded && partialFlattening.isEmpty()) {\n            for (int page = 1; page <= reader.getNumberOfPages(); ++page) {\n                PdfDictionary pageDic = reader.getPageN(page);\n                PdfArray annots = pageDic.getAsArray(PdfName.ANNOTS);\n                if (annots == null) continue;\n                for (int idx = 0; idx < annots.size(); ++idx) {\n                    PdfObject annoto = annots.getDirectObject(idx);\n                    if ((annoto instanceof PdfIndirectReference) && !annoto.isIndirect()) continue;\n                    if (!annoto.isDictionary() || PdfName.WIDGET.equals(((PdfDictionary) annoto).get(PdfName.SUBTYPE))) {\n                        annots.remove(idx);\n                        --idx;\n                    }\n                }\n                if (annots.isEmpty()) {\n                    PdfReader.killIndirect(pageDic.get(PdfName.ANNOTS));\n                    pageDic.remove(PdfName.ANNOTS);\n                }\n            }\n            eliminateAcroformObjects();\n        }\n    }\n\n    void eliminateAcroformObjects() {\n        PdfObject acro = reader.getCatalog().get(PdfName.ACROFORM);\n        if (acro == null) return;\n        PdfDictionary acrodic = (PdfDictionary) PdfReader.getPdfObject(acro);\n        reader.killXref(acrodic.get(PdfName.XFA));\n        acrodic.remove(PdfName.XFA);\n        PdfObject iFields = acrodic.get(PdfName.FIELDS);\n        if (iFields != null) {\n            PdfDictionary kids = new PdfDictionary();\n            kids.put(PdfName.KIDS, iFields);\n            sweepKids(kids);\n            PdfReader.killIndirect(iFields);\n            acrodic.put(PdfName.FIELDS, new PdfArray());\n        }\n    }\n\n    void sweepKids(PdfObject obj) {\n        PdfObject oo = PdfReader.killIndirect(obj);\n        if (oo == null || !oo.isDictionary()) return;\n        PdfDictionary dic = (PdfDictionary) oo;\n        PdfArray kids = (PdfArray) PdfReader.killIndirect(dic.get(PdfName.KIDS));\n        if (kids == null) return;\n        for (int k = 0; k < kids.size(); ++k) {\n            sweepKids(kids.getPdfObject(k));\n        }\n    }\n\n    private void flatFreeTextFields() {\n        if (append) throw new IllegalArgumentException(\"FreeText flattening is not supported in append mode.\");\n        for (int page = 1; page <= reader.getNumberOfPages(); ++page) {\n            PdfDictionary pageDic = reader.getPageN(page);\n            PdfArray annots = pageDic.getAsArray(PdfName.ANNOTS);\n            if (annots == null) continue;\n            for (int idx = 0; idx < annots.size(); ++idx) {\n                PdfObject annoto = annots.getDirectObject(idx);\n                if ((annoto instanceof PdfIndirectReference) && !annoto.isIndirect()) continue;\n                PdfDictionary annDic = (PdfDictionary) annoto;\n                if (!((PdfName) annDic.get(PdfName.SUBTYPE)).equals(PdfName.FREETEXT)) continue;\n                PdfNumber ff = annDic.getAsNumber(PdfName.F);\n                int flags = (ff != null) ? ff.intValue() : 0;\n                if ((flags & PdfFormField.FLAGS_PRINT) != 0 && (flags & PdfFormField.FLAGS_HIDDEN) == 0) {\n                    PdfObject obj1 = annDic.get(PdfName.AP);\n                    if (obj1 == null) continue;\n                    PdfDictionary appDic = (obj1 instanceof PdfIndirectReference) ? (PdfDictionary) PdfReader.getPdfObject(obj1) : (PdfDictionary) obj1;\n                    PdfObject obj = appDic.get(PdfName.N);\n                    PdfAppearance app = null;\n                    PdfObject objReal = PdfReader.getPdfObject(obj);\n                    if (obj instanceof PdfIndirectReference && !obj.isIndirect()) app = new PdfAppearance((PdfIndirectReference) obj); else if (objReal instanceof PdfStream) {\n                        ((PdfDictionary) objReal).put(PdfName.SUBTYPE, PdfName.FORM);\n                        app = new PdfAppearance((PdfIndirectReference) obj);\n                    } else {\n                        if (objReal.isDictionary()) {\n                            PdfName as_p = appDic.getAsName(PdfName.AS);\n                            if (as_p != null) {\n                                PdfIndirectReference iref = (PdfIndirectReference) ((PdfDictionary) objReal).get(as_p);\n                                if (iref != null) {\n                                    app = new PdfAppearance(iref);\n                                    if (iref.isIndirect()) {\n                                        objReal = PdfReader.getPdfObject(iref);\n                                        ((PdfDictionary) objReal).put(PdfName.SUBTYPE, PdfName.FORM);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (app != null) {\n                        Rectangle box = PdfReader.getNormalizedRectangle(annDic.getAsArray(PdfName.RECT));\n                        PdfContentByte cb = getOverContent(page);\n                        cb.setLiteral(\"Q \");\n                        cb.addTemplate(app, box.getLeft(), box.getBottom());\n                        cb.setLiteral(\"q \");\n                    }\n                }\n            }\n            for (int idx = 0; idx < annots.size(); ++idx) {\n                PdfDictionary annot = annots.getAsDict(idx);\n                if (annot != null) {\n                    if (PdfName.FREETEXT.equals(annot.get(PdfName.SUBTYPE))) {\n                        annots.remove(idx);\n                        --idx;\n                    }\n                }\n            }\n            if (annots.isEmpty()) {\n                PdfReader.killIndirect(pageDic.get(PdfName.ANNOTS));\n                pageDic.remove(PdfName.ANNOTS);\n            }\n        }\n    }\n\n    /**\n     * @see com.lowagie.text.pdf.PdfWriter#getPageReference(int)\n     */\n    public PdfIndirectReference getPageReference(int page) {\n        PdfIndirectReference ref = reader.getPageOrigRef(page);\n        if (ref == null) throw new IllegalArgumentException(\"Invalid page number \" + page);\n        return ref;\n    }\n\n    /**\n     * @see com.lowagie.text.pdf.PdfWriter#addAnnotation(com.lowagie.text.pdf.PdfAnnotation)\n     */\n    public void addAnnotation(PdfAnnotation annot) {\n        throw new RuntimeException(\"Unsupported in this context. Use PdfStamper.addAnnotation()\");\n    }\n\n    void addDocumentField(PdfIndirectReference ref) {\n        PdfDictionary catalog = reader.getCatalog();\n        PdfDictionary acroForm = (PdfDictionary) PdfReader.getPdfObject(catalog.get(PdfName.ACROFORM), catalog);\n        if (acroForm == null) {\n            acroForm = new PdfDictionary();\n            catalog.put(PdfName.ACROFORM, acroForm);\n            markUsed(catalog);\n        }\n        PdfArray fields = (PdfArray) PdfReader.getPdfObject(acroForm.get(PdfName.FIELDS), acroForm);\n        if (fields == null) {\n            fields = new PdfArray();\n            acroForm.put(PdfName.FIELDS, fields);\n            markUsed(acroForm);\n        }\n        if (!acroForm.contains(PdfName.DA)) {\n            acroForm.put(PdfName.DA, new PdfString(\"/Helv 0 Tf 0 g \"));\n            markUsed(acroForm);\n        }\n        fields.add(ref);\n        markUsed(fields);\n    }\n\n    void addFieldResources() throws IOException {\n        if (fieldTemplates.isEmpty()) return;\n        PdfDictionary catalog = reader.getCatalog();\n        PdfDictionary acroForm = (PdfDictionary) PdfReader.getPdfObject(catalog.get(PdfName.ACROFORM), catalog);\n        if (acroForm == null) {\n            acroForm = new PdfDictionary();\n            catalog.put(PdfName.ACROFORM, acroForm);\n            markUsed(catalog);\n        }\n        PdfDictionary dr = (PdfDictionary) PdfReader.getPdfObject(acroForm.get(PdfName.DR), acroForm);\n        if (dr == null) {\n            dr = new PdfDictionary();\n            acroForm.put(PdfName.DR, dr);\n            markUsed(acroForm);\n        }\n        markUsed(dr);\n        for (Iterator it = fieldTemplates.keySet().iterator(); it.hasNext(); ) {\n            PdfTemplate template = (PdfTemplate) it.next();\n            PdfFormField.mergeResources(dr, (PdfDictionary) template.getResources(), this);\n        }\n        PdfDictionary fonts = dr.getAsDict(PdfName.FONT);\n        if (fonts == null) {\n            fonts = new PdfDictionary();\n            dr.put(PdfName.FONT, fonts);\n        }\n        if (!fonts.contains(PdfName.HELV)) {\n            PdfDictionary dic = new PdfDictionary(PdfName.FONT);\n            dic.put(PdfName.BASEFONT, PdfName.HELVETICA);\n            dic.put(PdfName.ENCODING, PdfName.WIN_ANSI_ENCODING);\n            dic.put(PdfName.NAME, PdfName.HELV);\n            dic.put(PdfName.SUBTYPE, PdfName.TYPE1);\n            fonts.put(PdfName.HELV, addToBody(dic).getIndirectReference());\n        }\n        if (!fonts.contains(PdfName.ZADB)) {\n            PdfDictionary dic = new PdfDictionary(PdfName.FONT);\n            dic.put(PdfName.BASEFONT, PdfName.ZAPFDINGBATS);\n            dic.put(PdfName.NAME, PdfName.ZADB);\n            dic.put(PdfName.SUBTYPE, PdfName.TYPE1);\n            fonts.put(PdfName.ZADB, addToBody(dic).getIndirectReference());\n        }\n        if (acroForm.get(PdfName.DA) == null) {\n            acroForm.put(PdfName.DA, new PdfString(\"/Helv 0 Tf 0 g \"));\n            markUsed(acroForm);\n        }\n    }\n\n    void expandFields(PdfFormField field, ArrayList allAnnots) {\n        allAnnots.add(field);\n        ArrayList kids = field.getKids();\n        if (kids != null) {\n            for (int k = 0; k < kids.size(); ++k) expandFields((PdfFormField) kids.get(k), allAnnots);\n        }\n    }\n\n    void addAnnotation(PdfAnnotation annot, PdfDictionary pageN) {\n        try {\n            ArrayList allAnnots = new ArrayList();\n            if (annot.isForm()) {\n                fieldsAdded = true;\n                getAcroFields();\n                PdfFormField field = (PdfFormField) annot;\n                if (field.getParent() != null) return;\n                expandFields(field, allAnnots);\n            } else allAnnots.add(annot);\n            for (int k = 0; k < allAnnots.size(); ++k) {\n                annot = (PdfAnnotation) allAnnots.get(k);\n                if (annot.getPlaceInPage() > 0) pageN = reader.getPageN(annot.getPlaceInPage());\n                if (annot.isForm()) {\n                    if (!annot.isUsed()) {\n                        HashMap templates = annot.getTemplates();\n                        if (templates != null) fieldTemplates.putAll(templates);\n                    }\n                    PdfFormField field = (PdfFormField) annot;\n                    if (field.getParent() == null) addDocumentField(field.getIndirectReference());\n                }\n                if (annot.isAnnotation()) {\n                    PdfObject pdfobj = PdfReader.getPdfObject(pageN.get(PdfName.ANNOTS), pageN);\n                    PdfArray annots = null;\n                    if (pdfobj == null || !pdfobj.isArray()) {\n                        annots = new PdfArray();\n                        pageN.put(PdfName.ANNOTS, annots);\n                        markUsed(pageN);\n                    } else annots = (PdfArray) pdfobj;\n                    annots.add(annot.getIndirectReference());\n                    markUsed(annots);\n                    if (!annot.isUsed()) {\n                        PdfRectangle rect = (PdfRectangle) annot.get(PdfName.RECT);\n                        if (rect != null && (rect.left() != 0 || rect.right() != 0 || rect.top() != 0 || rect.bottom() != 0)) {\n                            int rotation = reader.getPageRotation(pageN);\n                            Rectangle pageSize = reader.getPageSizeWithRotation(pageN);\n                            switch(rotation) {\n                                case 90:\n                                    annot.put(PdfName.RECT, new PdfRectangle(pageSize.getTop() - rect.bottom(), rect.left(), pageSize.getTop() - rect.top(), rect.right()));\n                                    break;\n                                case 180:\n                                    annot.put(PdfName.RECT, new PdfRectangle(pageSize.getRight() - rect.left(), pageSize.getTop() - rect.bottom(), pageSize.getRight() - rect.right(), pageSize.getTop() - rect.top()));\n                                    break;\n                                case 270:\n                                    annot.put(PdfName.RECT, new PdfRectangle(rect.bottom(), pageSize.getRight() - rect.left(), rect.top(), pageSize.getRight() - rect.right()));\n                                    break;\n                            }\n                        }\n                    }\n                }\n                if (!annot.isUsed()) {\n                    annot.setUsed();\n                    addToBody(annot, annot.getIndirectReference());\n                }\n            }\n        } catch (IOException e) {\n            throw new ExceptionConverter(e);\n        }\n    }\n\n    void addAnnotation(PdfAnnotation annot, int page) {\n        annot.setPage(page);\n        addAnnotation(annot, reader.getPageN(page));\n    }\n\n    private void outlineTravel(PRIndirectReference outline) {\n        while (outline != null) {\n            PdfDictionary outlineR = (PdfDictionary) PdfReader.getPdfObjectRelease(outline);\n            PRIndirectReference first = (PRIndirectReference) outlineR.get(PdfName.FIRST);\n            if (first != null) {\n                outlineTravel(first);\n            }\n            PdfReader.killIndirect(outlineR.get(PdfName.DEST));\n            PdfReader.killIndirect(outlineR.get(PdfName.A));\n            PdfReader.killIndirect(outline);\n            outline = (PRIndirectReference) outlineR.get(PdfName.NEXT);\n        }\n    }\n\n    void deleteOutlines() {\n        PdfDictionary catalog = reader.getCatalog();\n        PRIndirectReference outlines = (PRIndirectReference) catalog.get(PdfName.OUTLINES);\n        if (outlines == null) return;\n        outlineTravel(outlines);\n        PdfReader.killIndirect(outlines);\n        catalog.remove(PdfName.OUTLINES);\n        markUsed(catalog);\n    }\n\n    void setJavaScript() throws IOException {\n        HashMap djs = pdf.getDocumentLevelJS();\n        if (djs.isEmpty()) return;\n        PdfDictionary catalog = reader.getCatalog();\n        PdfDictionary names = (PdfDictionary) PdfReader.getPdfObject(catalog.get(PdfName.NAMES), catalog);\n        if (names == null) {\n            names = new PdfDictionary();\n            catalog.put(PdfName.NAMES, names);\n            markUsed(catalog);\n        }\n        markUsed(names);\n        PdfDictionary tree = PdfNameTree.writeTree(djs, this);\n        names.put(PdfName.JAVASCRIPT, addToBody(tree).getIndirectReference());\n    }\n\n    void addFileAttachments() throws IOException {\n        HashMap fs = pdf.getDocumentFileAttachment();\n        if (fs.isEmpty()) return;\n        PdfDictionary catalog = reader.getCatalog();\n        PdfDictionary names = (PdfDictionary) PdfReader.getPdfObject(catalog.get(PdfName.NAMES), catalog);\n        if (names == null) {\n            names = new PdfDictionary();\n            catalog.put(PdfName.NAMES, names);\n            markUsed(catalog);\n        }\n        markUsed(names);\n        HashMap old = PdfNameTree.readTree((PdfDictionary) PdfReader.getPdfObjectRelease(names.get(PdfName.EMBEDDEDFILES)));\n        for (Iterator it = fs.entrySet().iterator(); it.hasNext(); ) {\n            Map.Entry entry = (Map.Entry) it.next();\n            String name = (String) entry.getKey();\n            int k = 0;\n            String nn = name;\n            while (old.containsKey(nn)) {\n                ++k;\n                nn += \" \" + k;\n            }\n            old.put(nn, entry.getValue());\n        }\n        PdfDictionary tree = PdfNameTree.writeTree(old, this);\n        names.put(PdfName.EMBEDDEDFILES, addToBody(tree).getIndirectReference());\n    }\n\n    /**\n     * Adds or replaces the Collection Dictionary in the Catalog.\n     * @param\tcollection\tthe new collection dictionary.\n     */\n    void makePackage(PdfCollection collection) {\n        PdfDictionary catalog = reader.getCatalog();\n        catalog.put(PdfName.COLLECTION, collection);\n    }\n\n    void setOutlines() throws IOException {\n        if (newBookmarks == null) return;\n        deleteOutlines();\n        if (newBookmarks.isEmpty()) return;\n        PdfDictionary catalog = reader.getCatalog();\n        boolean namedAsNames = (catalog.get(PdfName.DESTS) != null);\n        writeOutlines(catalog, namedAsNames);\n        markUsed(catalog);\n    }\n\n    /**\n     * Sets the viewer preferences.\n     * @param preferences the viewer preferences\n     * @see PdfWriter#setViewerPreferences(int)\n     */\n    public void setViewerPreferences(int preferences) {\n        useVp = true;\n        this.viewerPreferences.setViewerPreferences(preferences);\n    }\n\n    /** Adds a viewer preference\n     * @param key a key for a viewer preference\n     * @param value the value for the viewer preference\n     * @see PdfViewerPreferences#addViewerPreference\n     */\n    public void addViewerPreference(PdfName key, PdfObject value) {\n        useVp = true;\n        this.viewerPreferences.addViewerPreference(key, value);\n    }\n\n    /**\n     * Set the signature flags.\n     * @param f the flags. This flags are ORed with current ones\n     */\n    public void setSigFlags(int f) {\n        sigFlags |= f;\n    }\n\n    /** Always throws an <code>UnsupportedOperationException</code>.\n     * @param actionType ignore\n     * @param action ignore\n     * @throws PdfException ignore\n     * @see PdfStamper#setPageAction(PdfName, PdfAction, int)\n     */\n    public void setPageAction(PdfName actionType, PdfAction action) throws PdfException {\n        throw new UnsupportedOperationException(\"Use setPageAction(PdfName actionType, PdfAction action, int page)\");\n    }\n\n    /**\n     * Sets the open and close page additional action.\n     * @param actionType the action type. It can be <CODE>PdfWriter.PAGE_OPEN</CODE>\n     * or <CODE>PdfWriter.PAGE_CLOSE</CODE>\n     * @param action the action to perform\n     * @param page the page where the action will be applied. The first page is 1\n     * @throws PdfException if the action type is invalid\n     */\n    void setPageAction(PdfName actionType, PdfAction action, int page) throws PdfException {\n        if (!actionType.equals(PAGE_OPEN) && !actionType.equals(PAGE_CLOSE)) throw new PdfException(\"Invalid page additional action type: \" + actionType.toString());\n        PdfDictionary pg = reader.getPageN(page);\n        PdfDictionary aa = (PdfDictionary) PdfReader.getPdfObject(pg.get(PdfName.AA), pg);\n        if (aa == null) {\n            aa = new PdfDictionary();\n            pg.put(PdfName.AA, aa);\n            markUsed(pg);\n        }\n        aa.put(actionType, action);\n        markUsed(aa);\n    }\n\n    /**\n     * Always throws an <code>UnsupportedOperationException</code>.\n     * @param seconds ignore\n     */\n    public void setDuration(int seconds) {\n        throw new UnsupportedOperationException(\"Use setPageAction(PdfName actionType, PdfAction action, int page)\");\n    }\n\n    /**\n     * Always throws an <code>UnsupportedOperationException</code>.\n     * @param transition ignore\n     */\n    public void setTransition(PdfTransition transition) {\n        throw new UnsupportedOperationException(\"Use setPageAction(PdfName actionType, PdfAction action, int page)\");\n    }\n\n    /**\n     * Sets the display duration for the page (for presentations)\n     * @param seconds   the number of seconds to display the page. A negative value removes the entry\n     * @param page the page where the duration will be applied. The first page is 1\n     */\n    void setDuration(int seconds, int page) {\n        PdfDictionary pg = reader.getPageN(page);\n        if (seconds < 0) pg.remove(PdfName.DUR); else pg.put(PdfName.DUR, new PdfNumber(seconds));\n        markUsed(pg);\n    }\n\n    /**\n     * Sets the transition for the page\n     * @param transition   the transition object. A <code>null</code> removes the transition\n     * @param page the page where the transition will be applied. The first page is 1\n     */\n    void setTransition(PdfTransition transition, int page) {\n        PdfDictionary pg = reader.getPageN(page);\n        if (transition == null) pg.remove(PdfName.TRANS); else pg.put(PdfName.TRANS, transition.getTransitionDictionary());\n        markUsed(pg);\n    }\n\n    protected void markUsed(PdfObject obj) {\n        if (append && obj != null) {\n            PRIndirectReference ref = null;\n            if (obj.type() == PdfObject.INDIRECT) ref = (PRIndirectReference) obj; else ref = obj.getIndRef();\n            if (ref != null) marked.put(ref.getNumber(), 1);\n        }\n    }\n\n    protected void markUsed(int num) {\n        if (append) marked.put(num, 1);\n    }\n\n    /**\n     * Getter for property append.\n     * @return Value of property append.\n     */\n    boolean isAppend() {\n        return append;\n    }\n\n    /** Additional-actions defining the actions to be taken in\n     * response to various trigger events affecting the document\n     * as a whole. The actions types allowed are: <CODE>DOCUMENT_CLOSE</CODE>,\n     * <CODE>WILL_SAVE</CODE>, <CODE>DID_SAVE</CODE>, <CODE>WILL_PRINT</CODE>\n     * and <CODE>DID_PRINT</CODE>.\n     *\n     * @param actionType the action type\n     * @param action the action to execute in response to the trigger\n     * @throws PdfException on invalid action type\n     */\n    public void setAdditionalAction(PdfName actionType, PdfAction action) throws PdfException {\n        if (!(actionType.equals(DOCUMENT_CLOSE) || actionType.equals(WILL_SAVE) || actionType.equals(DID_SAVE) || actionType.equals(WILL_PRINT) || actionType.equals(DID_PRINT))) {\n            throw new PdfException(\"Invalid additional action type: \" + actionType.toString());\n        }\n        PdfDictionary aa = reader.getCatalog().getAsDict(PdfName.AA);\n        if (aa == null) {\n            if (action == null) return;\n            aa = new PdfDictionary();\n            reader.getCatalog().put(PdfName.AA, aa);\n        }\n        markUsed(aa);\n        if (action == null) aa.remove(actionType); else aa.put(actionType, action);\n    }\n\n    /**\n     * @see com.lowagie.text.pdf.PdfWriter#setOpenAction(com.lowagie.text.pdf.PdfAction)\n     */\n    public void setOpenAction(PdfAction action) {\n        openAction = action;\n    }\n\n    /**\n     * @see com.lowagie.text.pdf.PdfWriter#setOpenAction(java.lang.String)\n     */\n    public void setOpenAction(String name) {\n        throw new UnsupportedOperationException(\"Open actions by name are not supported.\");\n    }\n\n    /**\n     * @see com.lowagie.text.pdf.PdfWriter#setThumbnail(com.lowagie.text.Image)\n     */\n    public void setThumbnail(com.lowagie.text.Image image) {\n        throw new UnsupportedOperationException(\"Use PdfStamper.setThumbnail().\");\n    }\n\n    void setThumbnail(Image image, int page) throws PdfException, DocumentException {\n        PdfIndirectReference thumb = getImageReference(addDirectImageSimple(image));\n        reader.resetReleasePage();\n        PdfDictionary dic = reader.getPageN(page);\n        dic.put(PdfName.THUMB, thumb);\n        reader.resetReleasePage();\n    }\n\n    public PdfContentByte getDirectContentUnder() {\n        throw new UnsupportedOperationException(\"Use PdfStamper.getUnderContent() or PdfStamper.getOverContent()\");\n    }\n\n    public PdfContentByte getDirectContent() {\n        throw new UnsupportedOperationException(\"Use PdfStamper.getUnderContent() or PdfStamper.getOverContent()\");\n    }\n\n    /**\n     * Reads the OCProperties dictionary from the catalog of the existing document\n     * and fills the documentOCG, documentOCGorder and OCGRadioGroup variables in PdfWriter.\n     * Note that the original OCProperties of the existing document can contain more information.\n     * @since\t2.1.2\n     */\n    protected void readOCProperties() {\n        if (!documentOCG.isEmpty()) {\n            return;\n        }\n        PdfDictionary dict = reader.getCatalog().getAsDict(PdfName.OCPROPERTIES);\n        if (dict == null) {\n            return;\n        }\n        PdfArray ocgs = dict.getAsArray(PdfName.OCGS);\n        PdfIndirectReference ref;\n        PdfLayer layer;\n        HashMap ocgmap = new HashMap();\n        for (Iterator i = ocgs.listIterator(); i.hasNext(); ) {\n            ref = (PdfIndirectReference) i.next();\n            layer = new PdfLayer(null);\n            layer.setRef(ref);\n            layer.setOnPanel(false);\n            layer.merge((PdfDictionary) PdfReader.getPdfObject(ref));\n            ocgmap.put(ref.toString(), layer);\n        }\n        PdfDictionary d = dict.getAsDict(PdfName.D);\n        PdfArray off = d.getAsArray(PdfName.OFF);\n        if (off != null) {\n            for (Iterator i = off.listIterator(); i.hasNext(); ) {\n                ref = (PdfIndirectReference) i.next();\n                layer = (PdfLayer) ocgmap.get(ref.toString());\n                layer.setOn(false);\n            }\n        }\n        PdfArray order = d.getAsArray(PdfName.ORDER);\n        if (order != null) {\n            addOrder(null, order, ocgmap);\n        }\n        documentOCG.addAll(ocgmap.values());\n        OCGRadioGroup = d.getAsArray(PdfName.RBGROUPS);\n        OCGLocked = d.getAsArray(PdfName.LOCKED);\n        if (OCGLocked == null) OCGLocked = new PdfArray();\n    }\n\n    /**\n     * Recursive method to reconstruct the documentOCGorder variable in the writer.\n     * @param\tparent\ta parent PdfLayer (can be null)\n     * @param\tarr\t\tan array possibly containing children for the parent PdfLayer\n     * @param\tocgmap\ta HashMap with indirect reference Strings as keys and PdfLayer objects as values.\n     * @since\t2.1.2\n     */\n    private void addOrder(PdfLayer parent, PdfArray arr, Map ocgmap) {\n        PdfObject obj;\n        PdfLayer layer;\n        for (int i = 0; i < arr.size(); i++) {\n            obj = arr.getPdfObject(i);\n            if (obj.isIndirect()) {\n                layer = (PdfLayer) ocgmap.get(obj.toString());\n                layer.setOnPanel(true);\n                registerLayer(layer);\n                if (parent != null) {\n                    parent.addChild(layer);\n                }\n                if (arr.size() > i + 1 && arr.getPdfObject(i + 1).isArray()) {\n                    i++;\n                    addOrder(layer, (PdfArray) arr.getPdfObject(i), ocgmap);\n                }\n            } else if (obj.isArray()) {\n                PdfArray sub = (PdfArray) obj;\n                if (sub.isEmpty()) return;\n                obj = sub.getPdfObject(0);\n                if (obj.isString()) {\n                    layer = new PdfLayer(obj.toString());\n                    layer.setOnPanel(true);\n                    registerLayer(layer);\n                    if (parent != null) {\n                        parent.addChild(layer);\n                    }\n                    PdfArray array = new PdfArray();\n                    for (Iterator j = sub.listIterator(); j.hasNext(); ) {\n                        array.add((PdfObject) j.next());\n                    }\n                    addOrder(layer, array, ocgmap);\n                } else {\n                    addOrder(parent, (PdfArray) obj, ocgmap);\n                }\n            }\n        }\n    }\n\n    /**\n     * Gets the PdfLayer objects in an existing document as a Map\n     * with the names/titles of the layers as keys.\n     * @return\ta Map with all the PdfLayers in the document (and the name/title of the layer as key)\n     * @since\t2.1.2\n     */\n    public Map getPdfLayers() {\n        if (documentOCG.isEmpty()) {\n            readOCProperties();\n        }\n        HashMap map = new HashMap();\n        PdfLayer layer;\n        String key;\n        for (Iterator i = documentOCG.iterator(); i.hasNext(); ) {\n            layer = (PdfLayer) i.next();\n            if (layer.getTitle() == null) {\n                key = layer.getAsString(PdfName.NAME).toString();\n            } else {\n                key = layer.getTitle();\n            }\n            if (map.containsKey(key)) {\n                int seq = 2;\n                String tmp = key + \"(\" + seq + \")\";\n                while (map.containsKey(tmp)) {\n                    seq++;\n                    tmp = key + \"(\" + seq + \")\";\n                }\n                key = tmp;\n            }\n            map.put(key, layer);\n        }\n        return map;\n    }\n\n    static class PageStamp {\n\n        PdfDictionary pageN;\n\n        StampContent under;\n\n        StampContent over;\n\n        PageResources pageResources;\n\n        int replacePoint = 0;\n\n        PageStamp(PdfStamperImp stamper, PdfReader reader, PdfDictionary pageN) {\n            this.pageN = pageN;\n            pageResources = new PageResources();\n            PdfDictionary resources = pageN.getAsDict(PdfName.RESOURCES);\n            pageResources.setOriginalResources(resources, stamper.namePtr);\n        }\n    }\n}");
  }


  static Source createCode(String name, String... lines){
    return Source.from(name, String.join("\n", Arrays.asList(lines)));
  }
}
